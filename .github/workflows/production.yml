name: Deploy to Production

on:
  workflow_dispatch:
  push:
    branches: [ main ]

permissions:
  contents: read

env:
  FLY_API_TOKEN: ${{ secrets.FLY_DEPLOY_TOKEN }}

jobs:
  check-service:
    name: "ðŸ” Pre-Deploy Health Check"
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - uses: actions/checkout@v4
    - uses: superfly/flyctl-actions/setup-flyctl@master
    
    - name: Check service status
      env:
        SERVICE_URL: ${{ secrets.SERVICE_URL }}
      run: |
        echo "ðŸ” Checking current production service status..."
        if curl -f -s ${SERVICE_URL}/health > /dev/null; then
          echo "âœ… Service is currently running"
          echo "Deployment will proceed normally"
        else
          echo "âš ï¸ Service is currently DOWN"
          echo "Proceeding with deployment (service will start)"
        fi

  test-service:
    name: "ðŸ§ª Test Service"
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - uses: actions/checkout@v4
    - uses: supabase/setup-cli@v1
      with:
        version: latest

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.13'
        
    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true
        
    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v3
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}
        
    - name: Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction --no-root
      
    - name: Install project
      run: poetry install --no-interaction
      
    - name: Install Supabase
      run: make start-supabase

    - name: Run migrations on test database
      run: supabase migrations up

    - name: Run quality checks (format, lint, test)
      env:
        LLM_PROVIDER: ${{ secrets.LLM_PROVIDER }}
        STANDARD_MODEL: ${{ secrets.STANDARD_MODEL }}
        REASONING_MODEL: ${{ secrets.REASONING_MODEL }}
      run: |
        make format lint
        make test-cov
        
    - name: Upload coverage reports to Codecov
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.xml
        token: ${{ secrets.CODECOV_TOKEN }}

  migrate-database:
    name: "ðŸ—„ï¸ Apply Database Migrations"
    runs-on: ubuntu-latest
    needs: [check-service, test-service]
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - uses: actions/checkout@v4
    - uses: supabase/setup-cli@v1
      with:
        version: latest

    - name: Apply pending migrations
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
      run: |
        echo "ðŸ—„ï¸ Linking to Supabase project..."
        supabase link --project-ref ${{ secrets.SUPABASE_PROJECT_REF }} --password ${{ secrets.SUPABASE_DB_PASSWORD }} --yes
        
        echo "ðŸ”„ Applying pending migrations..."
        supabase migrations up --linked

  deploy-service:
    name: "ðŸš€ Deploy to Production"
    runs-on: ubuntu-latest
    needs: [check-service, test-service, migrate-database]
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - uses: actions/checkout@v4
    - uses: superfly/flyctl-actions/setup-flyctl@master

    - name: Deploy to production
      run: make deploy ENV=production

  validate-service:
    name: "âœ… Validate Deployment"
    runs-on: ubuntu-latest
    needs: [deploy-service, migrate-database]
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Health check
      env:
        SERVICE_URL: ${{ secrets.SERVICE_URL }}
      run: |
        echo "ðŸ” Validating deployment with health check..."
        
        # Wait up to 60 seconds for service to be healthy
        MAX_ATTEMPTS=12
        ATTEMPT=0
        
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          ATTEMPT=$((ATTEMPT + 1))
          echo "Attempt $ATTEMPT of $MAX_ATTEMPTS..."
          
          if curl -f -s ${SERVICE_URL}/health > /dev/null; then
            echo "âœ… Service is healthy and responding"
            echo "ðŸŽ‰ Deployment successful!"
            exit 0
          fi
          
          if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
            echo "Service not ready yet, waiting 5 seconds..."
            sleep 5
          fi
        done
        
        echo "âŒ Service is not responding after ${MAX_ATTEMPTS} attempts"
        echo "Deployment validation failed"
        exit 1

  acceptance-tests:
    name: "ðŸ”’ Acceptance Tests"
    runs-on: ubuntu-latest
    needs: [deploy-service, migrate-database, validate-service]
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.13'
        
    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true
        
    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v3
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}
        
    - name: Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction --no-root
      
    - name: Install project
      run: poetry install --no-interaction
      
    - name: Run acceptance tests
      env:
        CI: true
        SERVICE_URL: ${{ secrets.SERVICE_URL }}
        SERVICE_API_KEY: ${{ secrets.SERVICE_API_KEY }}
        LLM_PROVIDER: ${{ secrets.LLM_PROVIDER }}
        STANDARD_MODEL: ${{ secrets.STANDARD_MODEL }}
        REASONING_MODEL: ${{ secrets.REASONING_MODEL }}
      run: make test-acceptance
      
    - name: Upload acceptance test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: acceptance-test-results
        path: artifacts/acceptance/results.xml
        
    - name: Rollback on failure
      if: failure()
      uses: superfly/flyctl-actions/setup-flyctl@master
      
    - name: Execute rollback
      if: failure()
      run: |
        echo "âŒ Acceptance tests failed - rolling back deployment"
        flyctl releases --app language-quiz-app-production --image --json > releases.json
        PREVIOUS_IMAGE=$(jq -r '.[1].ImageRef' releases.json)
        echo "Rolling back to image: ${PREVIOUS_IMAGE}"
        flyctl deploy --app language-quiz-app-production --image "${PREVIOUS_IMAGE}" --strategy immediate
        echo "::error::Deployment rolled back due to acceptance test failures"
        exit 1